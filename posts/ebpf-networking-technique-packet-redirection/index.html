<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>eBPF Networking Techniques - Packet Redirection | a.programming.blog</title>
<link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/posts/>Posts</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>eBPF Networking Techniques - Packet Redirection</span></h1><h2 class=date>2023/12/10</h2></div><main><aside><nav id=TableOfContents><ul><li><a href=#packet-redirection>Packet Redirection</a></li><li><a href=#a-demonstration>A Demonstration</a><ul><li><a href=#proxy-arp>Proxy ARP</a></li><li><a href=#attaching-ebpf-to-tc-classifier>Attaching eBPF to TC Classifier</a></li><li><a href=#ebpf-redirect-implementation>eBPF Redirect Implementation</a></li></ul></li><li><a href=#how-it-works-as-of-kernel-v65>How it works (As of Kernel v6.5)</a></li><li><a href=#ingress-and-egress>Ingress and Egress</a></li><li><a href=#summing-it-up>Summing it up</a></li></ul></nav></aside><h1 id=ebpf-networking-techniques---packet-redirection>eBPF Networking Techniques - Packet Redirection</h1><p>This is the first post, of a planned many, to shed light on the various networking techniques eBPF makes available to a Linux network developer.</p><p>I started my career as a network engineer before I found programming interesting.
During this stent I was working with white box networking hardware more often then Linux.
A few years into this role however the &ldquo;commodity hardware&rdquo; trend took foot and Linux was being used in the network world far more often.
It has always stood out to me that Linux networking felt, different, compared to working with traditional network hardware.</p><p>In my opinion this is because Linux is extremely flexible and, from my experience, aims for maximum flexibility with its networking concepts.
This leads to the oft feeling that certain networking concepts, learned in the traditional network engineering world, do not cleanly map to Linux concepts.</p><p>For instance, wtf is a veth?
You can describe it as a virtual &ldquo;wire&rdquo;, but it is also represented as two network interface by Linux.
It&rsquo;s also an I/O pipe which is a systems programming thing.
Oh, and it can be plugged into a Linux bridge, in which case, one side of the interface disappears.
We&rsquo;ll be using veths a lot in these posts, figured I&rsquo;d introduce their flexibility now.</p><p>Scenarios like this have drove me to start writing about Linux networking, especially in the context of eBPF.
It doesn&rsquo;t hurt that it&rsquo;s also my favorite topic in computer science, so I&rsquo;m rather motivated to share my knowledge</p><p>I plan on writing a series posts which focus on a particular eBPF networking technique.
Each post should be &ldquo;bite-sized&rdquo; and small enough to read and worth through in maybe an hour or two.</p><p>eBPF is a dense topic and the Linux networking subsystem is (maybe) even denser, so it&rsquo;s inevitable that some details necessary for a complete understanding of a technique will be glossed over.
I&rsquo;ll do my best to link to subsequent reading, kernel source code, or other blog posts to fill in the knowledge gaps where possible.</p><p>Without further ado, the first eBPF networking technique I want to cover is packet redirection.</p><h2 id=packet-redirection>Packet Redirection</h2><p>Packet redirection is taking a packet from one network interface and injecting it into another.</p><p>Let&rsquo;s illustrate this with a diagram that also depicts our lab topology.
![[eBPF Packet Redirection Topology.drawio.png]]</p><p>The above illustrates the basic form of an eBPF redirect.
The dotted lines represent the packet&rsquo;s path while solid lines depict veth pairs.</p><p>Our topology consists of two network namespaces bridged together by a veth.
Lets assume <code>veth1@1</code> is in the host network namespace providing access to <code>netns_1</code> and routing is configured for end-to-end connectivity.</p><p>A packet is sent to the client in <code>netns_2</code> listening on <code>10.0.2.11:7777</code>.
An eBPF program is associated with <code>veth1@2</code> which will run when a packet is received.
This eBPF program performs an eBPF redirect to <code>veth2@1</code> which forwards the packet immediately to <code>veth2@2</code> in <code>netns_2</code>.
From here the Linux network stack will be employed to deliver the packet to the client process (this is called local delivery).</p><p>Notice in <code>netns_1</code> we actually hop over the Linux networking stack when moving the packet towards its final destination.
This is the interesting bit of the technique, we short-circuit packet delivery by jumping over a bunch of kernel functions in the processing of the packet.</p><p>In a typical network flow, pretty much like the one we see in <code>netns_2</code>, the Linux network stack would evaluate the packet, passing it to Layer 2 and Layer 3 processing before determining if the packet should be delivered locally or routed out an interface.
If our eBPF program can glean this knowledge however, we can skip the Linux network stack completely and inject the packet into the egress interface which moves the packet closer to it&rsquo;s destination.</p><h2 id=a-demonstration>A Demonstration</h2><p>Let&rsquo;s jump into some code.</p><p>I&rsquo;m going to assume you can build eBPF programs with libbpf, load them, and run them.
If you&rsquo;re not sure how to do this check out my post <a href=https://who.ldelossa.is/posts/bpf-zero-to-hero/>here</a>.</p><p>You can find the code <a href=https://github.com/ldelossa/ebpf-net/tree/main/packet_redirection>here</a></p><p><code>Makefile</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>MAKEFLAGS <span style=color:#f92672>+=</span> <span style=color:#f92672>--</span>no<span style=color:#f92672>-</span>print<span style=color:#f92672>-</span>directory 
</span></span><span style=display:flex><span>IP <span style=color:#f92672>=</span> sudo ip
</span></span><span style=display:flex><span>NETNS <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>$</span>(IP) netns
</span></span><span style=display:flex><span>EXEC <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>$</span>(NETNS) exec
</span></span><span style=display:flex><span>NET_1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;netns_1&#34;</span>
</span></span><span style=display:flex><span>NET_2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;netns_2&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>up: packet_redirect.bpf.o vmlinux.h
</span></span><span style=display:flex><span>	<span style=color:#75715e># Purging old environment...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>-</span>make down
</span></span><span style=display:flex><span>	<span style=color:#75715e># Creating network namespaces...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#960050;background-color:#1e0010>$</span>(NETNS) add <span style=color:#960050;background-color:#1e0010>$</span>(NET_1)
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(NETNS) add <span style=color:#960050;background-color:#1e0010>$</span>(NET_2)
</span></span><span style=display:flex><span>	<span style=color:#75715e># Configuring the following topology...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e># |host_ns              |netns_1              |netns_2                |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e># |veth1@1 10.0.1.10|---|veth1@2 10.0.1.11    |                       |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e># |                     |veth2@1 10.0.2.10|---|veth2@2 10.0.2.11      |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e># |                     |                     |server  10.0.2.11:8000 |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#960050;background-color:#1e0010>$</span>(IP) link add name veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>1</span> type veth peer name veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span> netns <span style=color:#960050;background-color:#1e0010>$</span>(NET_1)
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(IP) addr add <span style=color:#ae81ff>10.0.1.10</span><span style=color:#f92672>/</span><span style=color:#ae81ff>24</span> dev veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_1) ip addr add <span style=color:#ae81ff>10.0.1.11</span><span style=color:#f92672>/</span><span style=color:#ae81ff>24</span> dev veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_1) ip link add name veth2<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>1</span> type veth peer name veth2<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span> netns <span style=color:#960050;background-color:#1e0010>$</span>(NET_2)
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_1) ip addr add <span style=color:#ae81ff>10.0.2.10</span><span style=color:#f92672>/</span><span style=color:#ae81ff>24</span> dev veth2<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_2) ip addr add <span style=color:#ae81ff>10.0.2.11</span><span style=color:#f92672>/</span><span style=color:#ae81ff>24</span> dev veth2<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(IP) link set veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>1</span> up
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_1) ip link set veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span> up
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_1) ip link set veth2<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>1</span> up
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_2) ip link set veth2<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span> up
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(IP) route add <span style=color:#ae81ff>10.0.2.0</span><span style=color:#f92672>/</span><span style=color:#ae81ff>24</span> dev veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_2) ip route add <span style=color:#ae81ff>10.0.1.0</span><span style=color:#f92672>/</span><span style=color:#ae81ff>24</span> dev veth2<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># veth1@2 in netns_1 must proxy ARP requests for host_ns and netns_2 so
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e># host_ns can resolve MAC addresses for netns_2 and vice versa.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_1) <span style=color:#f92672>/</span>bin<span style=color:#f92672>/</span>sh <span style=color:#f92672>-</span>c <span style=color:#960050;background-color:#1e0010>&#39;</span>echo <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;</span> <span style=color:#f92672>/</span>proc<span style=color:#f92672>/</span>sys<span style=color:#f92672>/</span>net<span style=color:#f92672>/</span>ipv4<span style=color:#f92672>/</span>conf<span style=color:#f92672>/</span>veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span><span style=color:#f92672>/</span>proxy_arp<span style=color:#960050;background-color:#1e0010>&#39;</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># Hardcode veth2@2 to a dummy MAC for sake of demonstration purposes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_2) ip link set dev veth2<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span> addr <span style=color:#ae81ff>02</span><span style=color:#f92672>:</span><span style=color:#ae81ff>00</span><span style=color:#f92672>:</span><span style=color:#ae81ff>00</span><span style=color:#f92672>:</span><span style=color:#ae81ff>00</span><span style=color:#f92672>:</span><span style=color:#ae81ff>00</span><span style=color:#f92672>:</span><span style=color:#ae81ff>00</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># Attaching eBPF program...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_1) tc qdisc replace dev veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span> clsact
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_1) tc filter replace dev veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span> ingress bpf direct<span style=color:#f92672>-</span>action object<span style=color:#f92672>-</span>file <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#f92672>&lt;</span> section tc
</span></span><span style=display:flex><span>	<span style=color:#75715e># LISTENING FOR UDP PACKET @ 10.0.2.11 7777...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e># Use &#39;make listen&#39; to listen for another packet...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#960050;background-color:#1e0010>@</span>make listen
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.PHONY:
</span></span><span style=display:flex><span>down:
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(NETNS) del <span style=color:#960050;background-color:#1e0010>$</span>(NET_1)
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(NETNS) del <span style=color:#960050;background-color:#1e0010>$</span>(NET_2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.PHONY:
</span></span><span style=display:flex><span>listen:
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_2) nc <span style=color:#f92672>-</span>u <span style=color:#f92672>-</span>l <span style=color:#ae81ff>10.0.2.11</span> <span style=color:#ae81ff>7777</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>packet_redirect.bpf.o:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>%</span>.bpf.o: <span style=color:#f92672>%</span>.bpf.c vmlinux.h 
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>#</span> Compiling eBPF program...
</span></span><span style=display:flex><span>	clang <span style=color:#f92672>-</span>O2 <span style=color:#f92672>-</span>target bpf <span style=color:#f92672>-</span>g3 <span style=color:#f92672>-</span>c <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#f92672>&lt;</span> <span style=color:#f92672>-</span>o <span style=color:#960050;background-color:#1e0010>$@</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vmlinux.h: 
</span></span><span style=display:flex><span>	sudo bpftool btf dump file <span style=color:#f92672>/</span>sys<span style=color:#f92672>/</span>kernel<span style=color:#f92672>/</span>btf<span style=color:#f92672>/</span>vmlinux format c <span style=color:#f92672>&gt;</span> vmlinux.h 
</span></span></code></pre></div><p>While this may look a little involved, it compiles our eBPF program, sets up our network topology, configures routing, attaches our eBPF program, and starts a listening UDP server for testing all with our default target <code>up</code>.</p><p>A large chunk of the <code>up</code> target is creating our two network namespaces, wiring veths together, and adding routes.
I think the general topology setup is self explanatory, however I want to explicitly call out two interesting things happening in this Makefile.</p><h3 id=proxy-arp>Proxy ARP</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>	<span style=color:#75715e># veth1@2 in netns_1 must proxy ARP requests for host_ns and netns_2 so
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e># host_ns can resolve MAC addresses for netns_2 and vice versa.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_1) <span style=color:#f92672>/</span>bin<span style=color:#f92672>/</span>sh <span style=color:#f92672>-</span>c <span style=color:#960050;background-color:#1e0010>&#39;</span>echo <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;</span> <span style=color:#f92672>/</span>proc<span style=color:#f92672>/</span>sys<span style=color:#f92672>/</span>net<span style=color:#f92672>/</span>ipv4<span style=color:#f92672>/</span>conf<span style=color:#f92672>/</span>veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span><span style=color:#f92672>/</span>proxy_arp<span style=color:#960050;background-color:#1e0010>&#39;</span>
</span></span></code></pre></div><p>Consider what we&rsquo;d like to accomplish in our demo.
We want to send a packet to <code>10.0.2.11</code> from the host namespace and have it reach the client in <code>netns_2</code>.
When we try to craft a packet toward <code>10.0.2.11</code> from the host network namespace we need ARP to resolve a MAC address for this IP so it can be placed in the Layer 2 header.
The interface which owns <code>10.0.2.11</code> is only accessible by transiting<code>netns_1</code> however and <code>netns_1</code> has no reason to implicitly forward ARP request or responses for interfaces existing on its local links.
So, we need <code>netns_1</code> to act as a proxy for <code>netns_2</code>, responding on behalf of <code>netns_2</code> when ARP requests for <code>10.0.2.11</code> are encountered.</p><p>You could also just hard-code a mapping between <code>10.0.2.11</code> and the MAC address of <code>veth1@2</code> in the host network namespace neighbor table, but I find proxy ARP a bit more elegant as it works without using static mappings.</p><h3 id=attaching-ebpf-to-tc-classifier>Attaching eBPF to TC Classifier</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_1) tc qdisc replace dev veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span> clsact
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_1) tc filter replace dev veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span> ingress bpf direct<span style=color:#f92672>-</span>action object<span style=color:#f92672>-</span>file <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#f92672>&lt;</span> section tc
</span></span></code></pre></div><p>The Traffic Control subsystem is used for fine-grain packet queuing, policing, and filtering.</p><p>I don&rsquo;t want to dig too deep into the Traffic Control (TC) subsystem in Linux, as this would be an entire post of its own.
You should read the <a href=https://tldp.org/HOWTO/Traffic-Control-HOWTO/intro.html>Traffic Control HOWTO</a> for a better understanding of what those terms mean.
Suffice it to say the TC subsystem can be entered for every packet that it received or transmitted on an interface, making it a great place for eBPF hooks to be applied.</p><p>Let&rsquo;s summarize the above two lines:</p><ol><li>We add a <code>qdisc</code> of type <code>clsact</code> to <code>veth1@2</code> where we expect the eBPF redirect to occur<ol><li>The <code>qdisc</code> of type <code>clsact</code> allows us to attach eBPF filters which are triggered for every packet either entering or leaving the network interface.</li></ol></li><li>We then add our eBPF filter to the <code>qdisc</code> on <code>veth1@2</code> in the <code>ingress</code> direction instructing our eBPF program to be triggered on every received packet (as opposed to <code>egress</code> direction for every transmitted packet).<ol><li>The <code>direct-action</code> flag allows our eBPF filter program to actually act like an <code>action</code> which manipulates the packet, instead of a <code>classifier</code> which classifies the packet, allowing our filter to return <code>TC_ACT_REDIRECT</code> in our demonstration.</li></ol></li></ol><p>This attachment process and the flags used can be a bit confusing without a good mental map of the TC subsystem.
I suggesting reading <a href=https://tldp.org/HOWTO/Traffic-Control-HOWTO/intro.html>Traffic Control HOWTO</a> followed by a great post from my colleague: <a href=https://qmonnet.github.io/whirl-offload/2020/04/11/tc-bpf-direct-action/>Understanding tc “direct action” mode for BPF</a>
The former article helps paint a mental picture of the TC subsystem while the latter will help clear the confusion when you notice how the <code>clsact</code> works differently from traditional <code>qdisc</code> implementations.</p><h3 id=ebpf-redirect-implementation>eBPF Redirect Implementation</h3><p><code>redirect.bpf.c</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;vmlinux.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bpf/bpf_endian.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bpf/bpf_helpers.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ETH_P_IP 0x0800 </span><span style=color:#75715e>/* Internet Protocol packet	*/</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TC_ACT_OK 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TC_ACT_REDIRECT 7
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// the interface we will redirect to.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define TARGET_INTF 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>// the destination IP that determines if we will redirect the packet.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define DEST_IP 0x0a00020b  </span><span style=color:#75715e>// 10.0.2.11
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// look for an IPv4 packet with destination address 10.0.2.11 and redirect
</span></span></span><span style=display:flex><span><span style=color:#75715e>// it to a target interface.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>SEC</span>(<span style=color:#e6db74>&#34;tc&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>redirect</span>(<span style=color:#66d9ef>struct</span> __sk_buff <span style=color:#f92672>*</span>ctx) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data_end <span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)(__u64)(ctx<span style=color:#f92672>-&gt;</span>data_end);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data <span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)(__u64)(ctx<span style=color:#f92672>-&gt;</span>data);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> ethhdr <span style=color:#f92672>*</span>eth;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> iphdr <span style=color:#f92672>*</span>ipv4;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> ret;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bpf_printk</span>(<span style=color:#e6db74>&#34;redirect: handling packet</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// bounds check for verifier, packet&#39;s data must be at least as large
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// as an ethernet header and the non-variable portion of the IPv4 header.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ((data <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> ethhdr) <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> iphdr) <span style=color:#f92672>&gt;</span> data_end))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> TC_ACT_OK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    eth <span style=color:#f92672>=</span> data;
</span></span><span style=display:flex><span>    ipv4 <span style=color:#f92672>=</span> data <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> ethhdr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bpf_printk</span>(<span style=color:#e6db74>&#34;redirect: checking ethernet header for IPv4 proto: %x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>bpf_ntohs</span>(eth<span style=color:#f92672>-&gt;</span>h_proto));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>bpf_ntohs</span>(eth<span style=color:#f92672>-&gt;</span>h_proto) <span style=color:#f92672>!=</span> ETH_P_IP) <span style=color:#66d9ef>return</span> TC_ACT_OK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bpf_printk</span>(<span style=color:#e6db74>&#34;redirect: checking destination address is 10.0.2.11</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>bpf_ntohl</span>(ipv4<span style=color:#f92672>-&gt;</span>daddr) <span style=color:#f92672>!=</span> DEST_IP) <span style=color:#66d9ef>return</span> TC_ACT_OK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bpf_printk</span>(<span style=color:#e6db74>&#34;redirect: rewriting destination MAC</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	eth<span style=color:#f92672>-&gt;</span>h_dest[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x02</span>;
</span></span><span style=display:flex><span>	eth<span style=color:#f92672>-&gt;</span>h_dest[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00</span>;
</span></span><span style=display:flex><span>	eth<span style=color:#f92672>-&gt;</span>h_dest[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00</span>;
</span></span><span style=display:flex><span>	eth<span style=color:#f92672>-&gt;</span>h_dest[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00</span>;
</span></span><span style=display:flex><span>	eth<span style=color:#f92672>-&gt;</span>h_dest[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00</span>;
</span></span><span style=display:flex><span>	eth<span style=color:#f92672>-&gt;</span>h_dest[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bpf_printk</span>(<span style=color:#e6db74>&#34;redirect: performing redirect</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>bpf_redirect</span>(TARGET_INTF, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bpf_printk</span>(<span style=color:#e6db74>&#34;redirect: result: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ret);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> _license[] <span style=color:#a6e22e>SEC</span>(<span style=color:#e6db74>&#34;license&#34;</span>) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;GPL&#34;</span>;
</span></span></code></pre></div><p>The above is our eBPF program which redirects a packet destined to <code>10.0.2.11</code>.
Let&rsquo;s walk through this code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;vmlinux.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bpf/bpf_endian.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bpf/bpf_helpers.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ETH_P_IP 0x0800 </span><span style=color:#75715e>/* Internet Protocol packet	*/</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TC_ACT_OK 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TC_ACT_REDIRECT 7
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// the interface we will redirect to.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define TARGET_INTF 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>// the destination IP that determines if we will redirect the packet.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define DEST_IP 0x0a00020b  </span><span style=color:#75715e>// 10.0.2.11
</span></span></span></code></pre></div><p>We begin by defining some constants we will use later.
Because this is a demonstration we can hard-code some information for simplicity such as the interface ID we plan to redirect our packet too and the destination IP we are snooping for.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>SEC</span>(<span style=color:#e6db74>&#34;tc&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>redirect</span>(<span style=color:#66d9ef>struct</span> __sk_buff <span style=color:#f92672>*</span>ctx) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data_end <span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)(__u64)(ctx<span style=color:#f92672>-&gt;</span>data_end);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data <span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)(__u64)(ctx<span style=color:#f92672>-&gt;</span>data);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> ethhdr <span style=color:#f92672>*</span>eth;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> iphdr <span style=color:#f92672>*</span>ipv4;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> ret;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bpf_printk</span>(<span style=color:#e6db74>&#34;redirect: handling packet</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// bounds check for verifier, packet&#39;s data must be at least as large
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// as an ethernet header and the non-variable portion of the IPv4 header.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ((data <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> ethhdr) <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> iphdr) <span style=color:#f92672>&gt;</span> data_end))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> TC_ACT_OK;
</span></span></code></pre></div><p>We are writing a program which runs in the TC subsystem and various loaders (bpftool, tc, libbpf) expect these programs in a ELF section dubbed &ldquo;tc&rdquo;, so we put our <code>redirect</code> eBPF program in this section once compiled.</p><p>Within the first few lines of <code>redirect</code> we declare the variables we will use in this function.
We set <code>data</code> and <code>data_end</code> to point to the packet&rsquo;s data and we&rsquo;ll use these pointers to parse out information in the packet.</p><p>Finally, we perform a bounds check on our pointers ensuring the packet&rsquo;s data buffer carries at least a layer 2 and a layer 3 (not including options) header.
This is required before directly accessing packet data as the Kernel must verify your eBPF program only accesses valid memory.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>	eth <span style=color:#f92672>=</span> data;
</span></span><span style=display:flex><span>    ipv4 <span style=color:#f92672>=</span> data <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> ethhdr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bpf_printk</span>(<span style=color:#e6db74>&#34;redirect: checking ethernet header for IPv4 proto: %x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>bpf_ntohs</span>(eth<span style=color:#f92672>-&gt;</span>h_proto));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>bpf_ntohs</span>(eth<span style=color:#f92672>-&gt;</span>h_proto) <span style=color:#f92672>!=</span> ETH_P_IP) <span style=color:#66d9ef>return</span> TC_ACT_OK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bpf_printk</span>(<span style=color:#e6db74>&#34;redirect: checking destination address is 10.0.2.11</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>bpf_ntohl</span>(ipv4<span style=color:#f92672>-&gt;</span>daddr) <span style=color:#f92672>!=</span> DEST_IP) <span style=color:#66d9ef>return</span> TC_ACT_OK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bpf_printk</span>(<span style=color:#e6db74>&#34;redirect: rewriting destination MAC</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	eth<span style=color:#f92672>-&gt;</span>h_dest[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x02</span>;
</span></span><span style=display:flex><span>	eth<span style=color:#f92672>-&gt;</span>h_dest[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00</span>;
</span></span><span style=display:flex><span>	eth<span style=color:#f92672>-&gt;</span>h_dest[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00</span>;
</span></span><span style=display:flex><span>	eth<span style=color:#f92672>-&gt;</span>h_dest[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00</span>;
</span></span><span style=display:flex><span>	eth<span style=color:#f92672>-&gt;</span>h_dest[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00</span>;
</span></span><span style=display:flex><span>	eth<span style=color:#f92672>-&gt;</span>h_dest[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bpf_printk</span>(<span style=color:#e6db74>&#34;redirect: performing redirect</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>bpf_redirect</span>(TARGET_INTF, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bpf_printk</span>(<span style=color:#e6db74>&#34;redirect: result: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ret);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> ret;
</span></span></code></pre></div><p>After we are sure we can access both the layer 2 and layer 3 headers we can define our pointer variables to them.
Next we do some checks on the headers to ensure this is an IPv4 packet and its destined to <code>10.0.2.11</code>.</p><p>If it is, we need to rewrite the MAC address.
This is necessary because we do a redirect directly from the ingress path on <code>veth1@2</code> to the ingress path of <code>veth2@1</code>.
Because <code>veth2@1</code> is a veth it will immediate forward the packet to <code>veth2@2</code>.
If we do not rewrite the MAC ourselves the packet would arrive at <code>veth2@2</code> with the MAC of <code>veth1@2</code> and will be dropped during ingress processing due to a MAC mismatch between the packet and the interface.
Remember, we hard-code our MAC address of <code>veth2@2</code> in our Makefile so we know exactly what to rewrite the MAC to.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>	<span style=color:#75715e># Hardcode veth2@2 to a dummy MAC for sake of demonstration purposes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#960050;background-color:#1e0010>$</span>(EXEC) <span style=color:#960050;background-color:#1e0010>$</span>(NET_2) ip link set dev veth2<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>2</span> addr <span style=color:#ae81ff>02</span><span style=color:#f92672>:</span><span style=color:#ae81ff>00</span><span style=color:#f92672>:</span><span style=color:#ae81ff>00</span><span style=color:#f92672>:</span><span style=color:#ae81ff>00</span><span style=color:#f92672>:</span><span style=color:#ae81ff>00</span><span style=color:#f92672>:</span><span style=color:#ae81ff>00</span>
</span></span></code></pre></div><p>In a real-world example you&rsquo;d probably do an eBPF lookup to find the next-hop MAC to rewrite too.</p><p>Finally, we call the <code>bpf_redirect</code> helper to perform the eBPF redirect.
We call it with no flag which indicates we are forwarding to the target interface&rsquo;s ingress path, much more on in [[#Ingress and Egress direction]]</p><p>You can start this demonstration by running <code>make up</code> at the root.
If everything went well you shell will be sitting at this prompt:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># LISTENING FOR UDP PACKET @ 10.0.2.11 7777...</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Use &#39;make listen&#39; to listen for another packet...</span>
</span></span><span style=display:flex><span>sudo ip netns exec <span style=color:#e6db74>&#34;netns_2&#34;</span> nc -u -l 10.0.2.11 <span style=color:#ae81ff>7777</span>
</span></span></code></pre></div><p>You can then issue this command at the host namespace</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>echo <span style=color:#e6db74>&#34;hello&#34;</span> | nc -u 10.0.2.11 <span style=color:#ae81ff>7777</span>
</span></span></code></pre></div><p>You should see a &lsquo;hello&rsquo; in the terminal where you ran <code>make up</code>.
This indicates the packet successfully redirect to <code>veth2@1</code> and was delivered to the client in <code>netns_2</code>.</p><p>You can edit this code and simply run <code>make up</code> to compile and redeploy it, just make sure you do not have any shells open in either of the namespaces or else the environment cannot be torn down successfully.</p><h2 id=how-it-works-as-of-kernel-v65>How it works (As of Kernel v6.5)</h2><p>Writing the code and seeing the data arrive on your terminal is <a href=https://www.reddit.com/r/oddlysatisfying/comments/10igfs0/getting_out_every_bit_of_cheese/>oddly satisfying</a>, but lets try to understand how it works under the hood.</p><p>First lets look at the signature for <code>bpf_redirect</code> helper itself:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>bpf_redirect</span>(u32 ifindex, u64 flags)
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 	Description
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		Redirect the packet to another net device of index <span style=color:#f92672>*</span>ifindex<span style=color:#f92672>*</span>.
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		This helper is somewhat similar to <span style=color:#f92672>**</span>bpf_clone_redirect<span style=color:#f92672>**</span>\
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		(), except that the packet is not cloned, which provides
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		increased performance.
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		Except <span style=color:#66d9ef>for</span> XDP, both ingress and egress interfaces can be used
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		<span style=color:#66d9ef>for</span> redirection. The <span style=color:#f92672>**</span>BPF_F_INGRESS<span style=color:#f92672>**</span> value in <span style=color:#f92672>*</span>flags<span style=color:#f92672>*</span> is used
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		to make the <span style=color:#a6e22e>distinction</span> (ingress path is selected <span style=color:#66d9ef>if</span> the flag
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		is present, egress path otherwise). Currently, XDP only
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		supports redirection to the egress interface, and accepts no
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		flag at all.
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		The same effect can also be attained with the more generic
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		<span style=color:#f92672>**</span>bpf_redirect_map<span style=color:#f92672>**</span><span style=color:#960050;background-color:#1e0010>\</span> (), which uses a BPF map to store the
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		redirect target instead of providing it directly to the helper.
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 	Return
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		For XDP, the helper returns <span style=color:#f92672>**</span>XDP_REDIRECT<span style=color:#f92672>**</span> on success or
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		<span style=color:#f92672>**</span>XDP_ABORTED<span style=color:#f92672>**</span> on error. For other program types, the values
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		are <span style=color:#f92672>**</span>TC_ACT_REDIRECT<span style=color:#f92672>**</span> on success or <span style=color:#f92672>**</span>TC_ACT_SHOT<span style=color:#f92672>**</span> on
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span> 		error.
</span></span></code></pre></div><p>So, pretty simple right, ignoring the bits about XDP (we won&rsquo;t dig into this yet)?
Give it an interface and a direction and we&rsquo;ll move the packet there.</p><p>But, lets dig into the actual <a href=https://elixir.bootlin.com/linux/v6.5/source/net/core/filter.c#L2503>implementation</a> a bit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>BPF_CALL_2</span>(bpf_redirect, u32, ifindex, u64, flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> bpf_redirect_info <span style=color:#f92672>*</span>ri <span style=color:#f92672>=</span> <span style=color:#a6e22e>this_cpu_ptr</span>(<span style=color:#f92672>&amp;</span>bpf_redirect_info);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(flags <span style=color:#f92672>&amp;</span> (<span style=color:#f92672>~</span>(BPF_F_INGRESS) <span style=color:#f92672>|</span> BPF_F_REDIRECT_INTERNAL)))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> TC_ACT_SHOT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ri<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>=</span> flags;
</span></span><span style=display:flex><span>	ri<span style=color:#f92672>-&gt;</span>tgt_index <span style=color:#f92672>=</span> ifindex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> TC_ACT_REDIRECT;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, because I want to keep these articles focused more on demonstrations rather then Kernel code walks, which can get rather lengthily rather quickly, I won&rsquo;t explain the entire packet flow.
But it may strike you odd, as it struck me, that this implementation is very simple.
All we are doing is setting some flags and returning the <code>TC_ACT_REDIRECT</code> flag to the TC subsystem.</p><p>Keep in mind that this eBPF program is running within the context of the TC subsystem.
With a focus on the ingress packet path, let&rsquo;s take a look at the function responsible for running our eBPF TC filter and handling the response.
<a href>implementation</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>	<span style=color:#66d9ef>case</span> TC_ACT_REDIRECT:
</span></span><span style=display:flex><span>		<span style=color:#75715e>/* skb_mac_header check was done by cls/act_bpf, so
</span></span></span><span style=display:flex><span><span style=color:#75715e>		 * we can safely push the L2 header back before
</span></span></span><span style=display:flex><span><span style=color:#75715e>		 * redirecting to another netdev
</span></span></span><span style=display:flex><span><span style=color:#75715e>		 */</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>__skb_push</span>(skb, skb<span style=color:#f92672>-&gt;</span>mac_len);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>skb_do_redirect</span>(skb) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span>EAGAIN) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>__skb_pull</span>(skb, skb<span style=color:#f92672>-&gt;</span>mac_len);
</span></span><span style=display:flex><span>			<span style=color:#f92672>*</span>another <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#f92672>*</span>ret <span style=color:#f92672>=</span> NET_RX_SUCCESS;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> NULL;
</span></span></code></pre></div><p>Focusing on what occurs when the eBPF program returns <code>TC_ACT_DIRECT</code> we can see that the <a href=https://elixir.bootlin.com/linux/v6.5/source/net/core/filter.c#L2468><code>*skb_do_redirect*</code> function</a> is invoked.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>skb_do_redirect</span>(<span style=color:#66d9ef>struct</span> sk_buff <span style=color:#f92672>*</span>skb)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> bpf_redirect_info <span style=color:#f92672>*</span>ri <span style=color:#f92672>=</span> <span style=color:#a6e22e>this_cpu_ptr</span>(<span style=color:#f92672>&amp;</span>bpf_redirect_info);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> net <span style=color:#f92672>*</span>net <span style=color:#f92672>=</span> <span style=color:#a6e22e>dev_net</span>(skb<span style=color:#f92672>-&gt;</span>dev);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> net_device <span style=color:#f92672>*</span>dev;
</span></span><span style=display:flex><span>	u32 flags <span style=color:#f92672>=</span> ri<span style=color:#f92672>-&gt;</span>flags;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>	       <span style=color:#a6e22e>__bpf_redirect</span>(skb, dev, flags);
</span></span></code></pre></div><p>Taking a look at the interesting bits we see that we retrieve the <code>bpf_redirect_info</code> structure that we stashed our flags into during <code>bpf_redirect</code> and in our case we invoke the <code>__bpf_redirect</code> function.</p><p>I&rsquo;ll leave it to the reader to continue tracing this path our in the code.
It will eventually lead the packet being queued on another network device.</p><p>The key take away from the above is that <code>bpf_redirect</code> occurs outside of the eBPF program and the TC subsystem is designed to redirect the packet, not the actual eBPF program.</p><h2 id=ingress-and-egress>Ingress and Egress</h2><p>So I&rsquo;ve been throwing these terms &lsquo;ingress&rsquo; and &rsquo;egress&rsquo; around pretty loosely and I think there&rsquo;s some bits worth explaining here.</p><p>Within the context of TC, specifically with the <code>clsact qdisc</code>, the terms &lsquo;ingress&rsquo; and &rsquo;egress&rsquo; are referring to where your eBPF program is being attached.
The <code>ingress</code> keyword provided to the <code>tc filter replace</code> command will attach your eBPF program such that it runs for ever received packet.
Adversely, <code>egress</code> attaches your eBPF program such that it runs for ever transmitted packet.</p><p>Within the context of the <code>bpf_redirect</code> helper the terms <code>ingress</code> and <code>egress</code> are really referring to how the Linux subsystem interprets this redirected packet.</p><p>The kernel may look at the packet and determine it was just received by an interface and process it via the normal ingress packet flow, passing the packet up to each protocol handler and toward remote (not for us) or local (listening socket exists locally) delivery.
This is what occurs when the default flag of <code>0</code> is provided to the <code>bpf_redirect</code> helper.</p><p>Another flag exists called <code>BPF_F_EGRESS</code> which instructs the kernel to process this packet as if it was being transmitted.
Instead of the kernel taking the redirected packet and passing it up to protocols, it will pass the packet to the egress packet flow where it will be eventually transmitted by the hardware corresponding to the interface ID passed to the helper.</p><p>Let&rsquo;s use a great tool contributed by my colleagues called <a href=https://github.com/cilium/pwru.git>Packet Where Are You</a> to demonstrate this.</p><p>I keep this handy alias in my shell for quickly debugging eBPF programs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pwr<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;docker run --privileged --rm -t --pid=host -v /sys/kernel/debug/:/sys/kernel/debug/ cilium/pwru pwru&#39;</span>
</span></span><span style=display:flex><span>	/usr/bin/docker
</span></span></code></pre></div><p>Now run the following in your shell after pasting that alias in (this can be on your host, the kernel is the kernel, and tracing kernel functions isn&rsquo;t isolated by any namespacing.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pwr --output-meta dst 10.0.2.11
</span></span></code></pre></div><p>Now start the demo environment if you don&rsquo;t have it running with <code>make up</code>.
If you do have it running and you&rsquo;ve already sent a packet run <code>make listen</code> to listen for another packet (yes I&rsquo;m too lazy to script this :-p).
Now, send a packet off and you should see output from <code>pwr</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>echo <span style=color:#e6db74>&#34;hello&#34;</span> | nc -u 10.0.2.11 <span style=color:#ae81ff>7777</span>
</span></span></code></pre></div><p><em>Note: you may actually catch ARP the first time you run this command. If you see logs like <code>arp_solicited</code>, run it one more time after ARP has been processed. You&rsquo;ll know you have the right output when you see veths being identified with fields like this <code>iface=3(veth1@1)</code> in the log.</em></p><p>Let&rsquo;s pick out the relevant functions from the output that demonstrate how ingress and egress flags influence the redirect. Lines irrelevant to our explanation are skipped.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc859bc3c00</span>      <span style=color:#ae81ff>7</span>    [<span style=color:#a6e22e>nc</span>(<span style=color:#ae81ff>3184970</span>)]         __dev_queue_xmit netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535320</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>(veth1<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>1</span>) proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>48</span> <span style=color:#75715e>// veth1@1 preparing to transmit to its veth1@2 pair
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc9d885f300</span>      <span style=color:#ae81ff>6</span>    [<span style=color:#a6e22e>nc</span>(<span style=color:#ae81ff>3195225</span>)]               __netif_rx netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535460</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>34</span> <span style=color:#75715e>// veth1@2 receiving the packet
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc9d885f300</span>      <span style=color:#ae81ff>6</span> [<span style=color:#f92672>&lt;</span>empty<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3195225</span>)] __netif_receive_skb_one_core netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535460</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>34</span> <span style=color:#75715e>// veth2@2 begins ingress packet processing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc9d885f300</span>      <span style=color:#ae81ff>6</span> [<span style=color:#f92672>&lt;</span>empty<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3195225</span>)]             tcf_classify netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535460</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>34</span> <span style=color:#75715e>// enter TC subsystem where our eBPF program runs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc9d885f300</span>      <span style=color:#ae81ff>6</span> [<span style=color:#f92672>&lt;</span>empty<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3195225</span>)]          skb_do_redirect netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535460</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>48</span> <span style=color:#75715e>// invoke a redirection for this packet
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc9d885f300</span>      <span style=color:#ae81ff>6</span> [<span style=color:#f92672>&lt;</span>empty<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3195225</span>)]           __bpf_redirect netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535460</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>48</span> <span style=color:#75715e>// use our eBPF structure to perform redirect
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc9d885f300</span>      <span style=color:#ae81ff>6</span> [<span style=color:#f92672>&lt;</span>empty<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3195225</span>)]         __dev_queue_xmit netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535460</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>48</span> <span style=color:#75715e>// the important part! 
</span></span></span></code></pre></div><p>The above ends with the <code>__dev_queue_xmit</code> function being invoked with <code>iface=3</code>.
In our case this is the <code>veth2@2</code> interface in <code>netns_1</code> which is where we redirect the packet to.
The important part here is we immediately wind up in the transmission function for the device, or in other words the packet will be transmitted on <code>veth2@2</code> after the redirect is processed.</p><p>Now, I want us to change <code>packet_redirect.bpf.c:49</code> to the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>	ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>bpf_redirect</span>(TARGET_INTF, BPF_F_INGRESS);
</span></span></code></pre></div><p>Run <code>make up</code> to rebuild the environment and follow the same steps to get <code>pwr</code> output.</p><p>Let&rsquo;s pick up right at <code>skb_do_redirect</code> this time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc8544c3e00</span>      <span style=color:#ae81ff>3</span> [<span style=color:#f92672>&lt;</span>empty<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3223205</span>)]          skb_do_redirect netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535561</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>48</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc8544c3e00</span>      <span style=color:#ae81ff>3</span> [<span style=color:#f92672>&lt;</span>empty<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3223205</span>)]           __bpf_redirect netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535561</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>48</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc8544c3e00</span>      <span style=color:#ae81ff>3</span> [<span style=color:#f92672>&lt;</span>empty<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3223205</span>)]        netif_rx_internal netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535561</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>34</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc8544c3e00</span>      <span style=color:#ae81ff>3</span> [<span style=color:#f92672>&lt;</span>empty<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3223205</span>)]       enqueue_to_backlog netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535561</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>34</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc8544c3e00</span>      <span style=color:#ae81ff>3</span> [<span style=color:#f92672>&lt;</span>empty<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3223205</span>)]      __netif_receive_skb netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535561</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>34</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0xffff8fc8544c3e00</span>      <span style=color:#ae81ff>3</span> [<span style=color:#f92672>&lt;</span>empty<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3223205</span>)] __netif_receive_skb_one_core netns<span style=color:#f92672>=</span><span style=color:#ae81ff>4026535561</span> mark<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0</span> iface<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> proto<span style=color:#f92672>=</span><span style=color:#ae81ff>0x0800</span> mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> len<span style=color:#f92672>=</span><span style=color:#ae81ff>34</span>
</span></span></code></pre></div><p>Notice now when the <code>BPF_F_INGRESS</code> flag is used we wind up in the ingress packet path of the kernel with <code>iface=3</code> which is <code>veth2@2</code>.
The usage of will result in the packet being &ldquo;recirculated&rdquo; into <code>netns_1</code> but with a source interface of <code>veth2@2</code>.</p><p>Keep in mind your <code>veth</code> identifications may be slightly different, since I run my demo environment inside a dedicated eBPF development container.
If you run the demo directly on your host machine the output will vary slightly but the general packet flow should remain the same.</p><h2 id=summing-it-up>Summing it up</h2><p>eBPF packet redirection is a common technique especially in container orchestration software like Kubernetes.
Cilium, which I work on as my day job, uses this all the time to move packets between containers.</p><p>There are a few other ways to perform packet redirection in the Kernel which build on this basic technique.
I&rsquo;ll be covering those next.
Follow me on the <a href=https://fosstodon.org/@ldelossa>social mediaz</a> if you&rsquo;re interested in more posts like this.</p></main><footer></footer></body></html>